<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projeto — Aferidor Inteligente de Pneus</title>
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <header class="hero" role="banner">
        <h1>Aferidor Inteligente de Pneus</h1>
        <h2>Projeto Técnico</h2>
        <p>Segurança, economia e tecnologia embarcadas em um equipamento portátil — projeto acadêmico integrado com ESP32 e sensores digitais.</p>
        
    </header>
    <nav>
        <a href="index.html">Início</a>
        <a class="active_page" href="projeto.html">Projeto</a>
        <a href="prototipo.html">Protótipo</a>
        <a href="contato.html">Contato</a>
    </nav>

    <main>

        <section class="tech-hero">
            <h2 class="section-title">Resumo do sistema</h2>
            <p>
                O <strong>Aferidor Inteligente de Pneus</strong> é um dispositivo portátil que utiliza ESP32 para ler sensores de pressão e temperatura (BMP280 e SMP3011), exibir dados em um display OLED SSD1306 e guiar o usuário em dois modos: <em>Modo Padrão</em> (leituras diretas) e <em>Modo Analítico</em> (entrada de parâmetros e sugestão de calibragem).
            </p>
            <div class="button-container mt-1">
                <div class="flex-item-small card">
                <h3 class="card-title">Escopo</h3>
                <ul>
                    <li>Leitura de pressão do pneu (SMP3011)</li>
                    <li>Leitura de pressão atmosférica e temperatura (BMP280)</li>
                    <li>Exibição no OLED SSD1306</li>
                    <li>Navegação por 3 botões (Up, Down, Confirm/Mode)</li>
                    <li>Sugestão de calibragem no modo analítico</li>
                </ul>
                </div>
               <div class="flex-item-small card">
                <h3 class="card-title">Público-alvo</h3>  <p>Motoristas, oficinas rápidas, frotas e entusiastas automotivos que desejam uma solução portátil, independente de apps, para aferição e recomendações de calibragem.</p>
                </div>
            </div>
        </section>

        <section class="mt-1">
            <h2 class="section-title">1. Especificação de Hardware</h2>

            <div class="two-col">
                <div>
                <h3>1.1 Componentes principais</h3>
                <ul>
                    <li><strong>ESP32 DevKit V1</strong> — Microcontrolador (Dual-core Xtensa LX6, Wi-Fi/Bluetooth) para controle e processamento.</li>
                    <li><strong>BMP280</strong> — Sensor barométrico com leitura de pressão (hPa) e temperatura (°C). Interface I2C/SPI.</li>
                    <li><strong>SMP3011</strong> — Sensor de pressão absoluta/diferencial (específico para medir pressão de pneu) com saída digital/analógica conforme modelo.</li>
                    <li><strong>OLED SSD1306 (128×64, I2C)</strong> — Interface gráfica para exibição de menus e valores.</li>
                    <li><strong>3 Botões físicos</strong> — BTN1 (Up), BTN2 (Down), BTN3 (Confirm / duplo-clique = troca de modo).</li>
                    <li><strong>Bateria Li-Ion 18650 + circuito de carga via USB</strong> — Alimentação portátil.</li>
                    <li><strong>Case impresso em 3D</strong> — Ergonomia e proteção.</li>
                </ul>

                <h3>1.2 Guia de pinos (conexões)</h3>
                <p class="small">Exemplo de ligação usando interface I2C e GPIOs do ESP32:</p>
                <table class="specs mt-0-6">
                    <tr><th>Componente</th><th>ESP32 (pino)</th><th>Observação</th></tr>
                    <tr><td>SSD1306 (SDA)</td><td>GPIO21</td><td>I2C SDA</td></tr>
                    <tr><td>SSD1306 (SCL)</td><td>GPIO22</td><td>I2C SCL</td></tr>
                    <tr><td>BMP280 (SDA)</td><td>GPIO21</td><td>Compartilha I2C</td></tr>
                    <tr><td>BMP280 (SCL)</td><td>GPIO22</td><td>Compartilha I2C</td></tr>
                    <tr><td>SMP3011 (SDA)</td><td>GPIO21</td><td>Compartilha I2C</td></tr>
                    <tr><td>SMP3011 (SCL)</td><td>GPIO22</td><td>Compartilha I2C</td></tr>                   
                    <tr><td>BTN1 (UP)</td><td>GPIO32</td><td>PULLUP</td></tr>
                    <tr><td>BTN2 (DOWN)</td><td>GPIO33</td><td>PULLUP</td></tr>
                    <tr><td>BTN3 (CONF/DUO)</td><td>GPIO25</td><td>PULLUP (botão ao GND)</td></tr>
                    <tr><td>Battery CHG</td><td>Micro-USB</td><td>Módulo de carga TP4056</td></tr>
                </table>

                <div class="note">
                    <strong>Nota:</strong> Escolha de pinos pode variar conforme a placa ESP32 (TTGO, Wemos, etc.). GPIOs 34-39 são ADC-only (entrada), não devem ser usados para saída.
                </div>
                </div>

                <div>
                <div class="diagram">
                    <h4 class="diagram-title">Diagrama de blocos (simplificado)</h4>
                    <pre class="diagram-pre">
        +------------------+
        |  Bateria / USB   |
        +--------+---------+
                |
            +---v---+
            | ESP32 |
            +---+---+
        I2C |   | I2C
        +----v+  +v-----+
        | SSD1306  SMP3011 |
        | (OLED)   (PRESS) |
        +----+     +------+
            |
BMP280 (I2C) - pressão atmos. & temp.
                    </pre>
                    <p class="small diagram-caption">Figura: arquitetura lógica — ESP32 centraliza sensores, processa e apresenta no OLED.</p>
                </div>

                <div class="card mt-1">
                    <h4 class="card-title">Especificações elétricas essenciais</h4>
                    <ul>
                    <li>Tensão de operação ESP32: 3.3 V</li>
                    <li>Tensão tolerada pelo SSD1306 (módulo com regulador): 3.3–5 V</li>
                    <li>Consumo típico em operação: 80–250 mA (depende do uso do Wi-Fi)</li>
                    <li>Recomendação: usar conversores de nível se houver sinal de 5V</li>
                    </ul>
                </div>
                </div>
            </div>
        </section>

        <section class="mt-1">
            <h2 class="section-title">2. Requisitos do Sistema (Engenharia de Software)</h2>

            <h3>2.1 Requisitos Funcionais (detalhados)</h3>
            <ol>
                <li>RF01 — Iniciar no Modo Padrão automaticamente ao ligar.</li>
                <li>RF02 — Ler e mostrar a cada 500 ms: pressão do pneu (psi/bar) e temperatura ambiente (ºC).</li>
                <li>RF03 — Detectar duplo clique em BTN3 para alternar entre Modo Padrão e Modo Analítico.</li>
                <li>RF04 — No Modo Analítico: permitir entrada sequencial de parâmetros via BTN1/BTN2/BTN3 (tipo veículo, tipo de pneu, carga).</li>
                <li>RF05 — Calcular e exibir sugestão de calibragem (diferença entre recomendada e medida atual).</li>
                <li>RF06 — Salvar última configuração de usuário na EEPROM/Preferences.</li>
            </ol>

            <h3>2.2 Requisitos Não Funcionais</h3>
            <ul>
                <li>RNF01 — Tempo de resposta máximo entre leitura do sensor e atualização do display: 500 ms.</li>
                <li>RNF02 — Firmware modular e documentado, com camadas: drivers, UI, lógica analítica.</li>
                <li>RNF03 — Tolerância a ruído em botões (debounce) e proteção contra leituras espúrias.</li>
                <li>RNF04 — Dispositivo robusto (IP desejado: IP54) e operação entre 0°C e 45°C.</li>
            </ul>
        </section>

        <section class="mt-1">
            <h2 class="section-title">3. Máquina de Estados (FSM) e Interação</h2>

            <h3>Estados principais</h3>
            <ul>
                <li><strong>BOOT</strong> — Inicialização e auto-test dos sensores</li>
                <li><strong>PADRÃO</strong> — Tela com leituras em tempo real</li>
                <li><strong>ANALÍTICO: CONFIGURAÇÃO</strong> — Sequência de seleção (Veículo → Pneu → Carga)</li>
                <li><strong>ANALÍTICO: RESULTADO</strong> — Exibe cálculo e sugestão</li>
                <li><strong>ERROR</strong> — Erro de leitura / sensor ausente</li>
            </ul>

            <h3>Eventos</h3>
            <ul>
                <li>BTN1 (UP) — move seleção para cima ou incrementa valor</li>
                <li>BTN2 (DOWN) — move seleção para baixo ou decrementa</li>
                <li>BTN3 (SHORT) — confirma seleção</li>
                <li>BTN3 (DOUBLE) — alterna PADRÃO ↔ ANALÍTICO</li>
            </ul>

            <div class="diagram mt-0-8">
                <strong>Fluxo simplificado do duplo clique (BTN3)</strong>
                <pre class="diagram-pre">
        BTN3 pressed --> start timer
        if pressed again within 500ms --> double-click --> toggle mode
        else if timer expires --> single click -> confirm current selection
                </pre>
            </div>
        </section>

        <section class="mt-1">
            <h2 class="section-title">4. Algoritmo Analítico: como sugerimos a calibragem</h2>

            <p>
                A sugestão de calibragem deve considerar:
            </p>
            <ul>
                <li>Pressão atual medida (P_meas)</li>
                <li>Pressão recomendada de fábrica (P_rec) — valor informado pelo usuário ou extraído de banco</li>
                <li>Compensação de temperatura (ΔT) — pneus quentes exigem pressão corrigida</li>
                <li>Carga do veículo (fator de ajuste)</li>
            </ul>

            <h4>Fórmula prática (exemplo)</h4>
            <p class="small">Observação: fórmula simplificada para uso didático. Em aplicação comercial, usar curvas e tabelas do fabricante.</p>

            <pre class="code-block">
        P_sugerida = P_rec + F_carga + k * (T_atual - T_ref)
        onde:
        P_rec   = pressão recomendada (psi)
        F_carga = { Leve: 0, Média: +1, Pesada: +2 } (psi)
        k       = coeficiente de correção por temperatura (ex: 0.03 psi/°C)
        T_ref   = temperatura de referência (ex: 20 °C)
            </pre>

            <p>Exemplo: P_rec = 32 psi, carga = Média (F_carga=+1), T_atual=35°C, k=0.03 → P_sugerida = 32 + 1 + 0.03*(35-20) = 33.45 psi → sugerir 33.5 psi.</p>
            <div class="note">Importante: O coeficiente k e os fatores de carga devem ser ajustados em testes experimentais e/ou baseados na literatura técnica do fabricante.</div>
        </section>

        <section class="mt-1">
            <h2 class="section-title">5. Firmware — Código exemplificativo</h2>

            <p class="small">O código abaixo é um esqueleto pronto para compilar (adaptar pinos conforme sua placa e versão do sensor SMP3011).</p>

            
            <pre class="code"><code class="code">
#include "iostream"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "driver/gpio.h"

#include "i2c_driver.h"
#include "bmp280.h"
#include "smp3011.h"
#include "ssd1306.h"
#include "button_driver.h"

static const char *TAG = "MAIN";

// Enum para os modos de operação
typedef enum {
    MODE_STANDARD,
    MODE_ANALYTICAL_VEHICLE_TYPE,
    MODE_ANALYTICAL_LOAD_TYPE,
    MODE_ANALYTICAL_RESULT
} operating_mode_t;

static operating_mode_t current_mode = MODE_STANDARD;

// Variáveis para o modo analítico
static int selected_vehicle_type = 0; // 0: Carro de Passeio, 1: SUV/Caminhonete
static int selected_load_type = 0;    // 0: Vazio, 1: Carga Média, 2: Carga Máxima

// Definições de pinos para os botões (redefinidas para clareza no main)
#define BUTTON_UP_PIN       GPIO_NUM_0  // Exemplo de pino para o Botão UP
#define BUTTON_DOWN_PIN     GPIO_NUM_4  // Exemplo de pino para o Botão DOWN
#define BUTTON_SELECT_PIN   GPIO_NUM_5  // Exemplo de pino para o Botão SELECT/MODE

// Protótipos de funções
void display_standard_mode(float temperature, float pressure_hpa, float pressure_psi);
void display_analytical_vehicle_type_selection();
void display_analytical_load_type_selection();
void display_analytical_result();
void handle_button_press(gpio_num_t gpio_num);

// Fila de eventos para botões
static xQueueHandle gpio_evt_queue = NULL;

static void IRAM_ATTR gpio_isr_handler(void* arg) {
    uint32_t gpio_num = (uint32_t) arg;
    xQueueSendFromISR(gpio_evt_queue, &gpio_num, NULL);
}

void button_task(void* arg) {
    uint32_t io_num;
    uint32_t last_press_time[GPIO_NUM_MAX] = {0};
    const uint32_t debounce_time_ms = 200; // Tempo de debounce

    while(1) {
        if(xQueueReceive(gpio_evt_queue, &io_num, portMAX_DELAY)) {
            uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
            if (current_time - last_press_time[io_num] > debounce_time_ms) {
                last_press_time[io_num] = current_time;
                handle_button_press((gpio_num_t)io_num);
            }
        }
    }
}

// Função para lidar com o pressionamento dos botões
void handle_button_press(gpio_num_t gpio_num) {
    static uint32_t last_mode_button_press_time = 0;
    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;

    if (gpio_num == BUTTON_SELECT_PIN) {
        // Lógica para alternar modos (dois cliques rápidos)
        if (current_time - last_mode_button_press_time < 500) { // Dois cliques em menos de 500ms
            if (current_mode == MODE_STANDARD) {
                current_mode = MODE_ANALYTICAL_VEHICLE_TYPE;
                ESP_LOGI(TAG, "Mudando para Modo Analítico: Seleção de Tipo de Veículo");
            } else {
                current_mode = MODE_STANDARD;
                ESP_LOGI(TAG, "Mudando para Modo Padrão");
            }
            last_mode_button_press_time = 0; // Reseta para evitar múltiplos switches
        } else {
            last_mode_button_press_time = current_time;
            // Lógica para seleção/confirmação no modo analítico
            if (current_mode == MODE_ANALYTICAL_VEHICLE_TYPE) {
                current_mode = MODE_ANALYTICAL_LOAD_TYPE;
                ESP_LOGI(TAG, "Modo Analítico: Seleção de Tipo de Carga");
            } else if (current_mode == MODE_ANALYTICAL_LOAD_TYPE) {
                current_mode = MODE_ANALYTICAL_RESULT;
                ESP_LOGI(TAG, "Modo Analítico: Exibindo Resultado");
            } else if (current_mode == MODE_ANALYTICAL_RESULT) {
                current_mode = MODE_ANALYTICAL_VEHICLE_TYPE; // Volta para seleção de veículo para nova análise
                ESP_LOGI(TAG, "Modo Analítico: Reiniciando Seleção de Tipo de Veículo");
            }
        }
    } else if (gpio_num == BUTTON_UP_PIN) {
        if (current_mode == MODE_ANALYTICAL_VEHICLE_TYPE) {
            selected_vehicle_type = (selected_vehicle_type + 1) % 2; // 0 ou 1
            ESP_LOGI(TAG, "Tipo de Veículo Selecionado: %d", selected_vehicle_type);
        } else if (current_mode == MODE_ANALYTICAL_LOAD_TYPE) {
            selected_load_type = (selected_load_type + 1) % 3; // 0, 1 ou 2
            ESP_LOGI(TAG, "Tipo de Carga Selecionado: %d", selected_load_type);
        }
    } else if (gpio_num == BUTTON_DOWN_PIN) {
        if (current_mode == MODE_ANALYTICAL_VEHICLE_TYPE) {
            selected_vehicle_type = (selected_vehicle_type - 1 + 2) % 2; // 0 ou 1
            ESP_LOGI(TAG, "Tipo de Veículo Selecionado: %d", selected_vehicle_type);
        } else if (current_mode == MODE_ANALYTICAL_LOAD_TYPE) {
            selected_load_type = (selected_load_type - 1 + 3) % 3; // 0, 1 ou 2
            ESP_LOGI(TAG, "Tipo de Carga Selecionado: %d", selected_load_type);
        }
    }
}

// Função para exibir dados no modo padrão
void display_standard_mode(float temperature, float pressure_hpa, float pressure_psi) {
    char temp_str[32];
    char press_hpa_str[32];
    char press_psi_str[32];

    snprintf(temp_str, sizeof(temp_str), "Temp: %.1f C", temperature);
    snprintf(press_hpa_str, sizeof(press_hpa_str), "Press: %.1f hPa", pressure_hpa);
    snprintf(press_psi_str, sizeof(press_psi_str), "Pneu: %.1f PSI", pressure_psi);

    ssd1306_clear_display(SSD1306_I2C_ADDR);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Modo Padrao", 0, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, temp_str, 2, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, press_hpa_str, 3, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, press_psi_str, 4, 0);
}

void display_analytical_vehicle_type_selection() {
    ssd1306_clear_display(SSD1306_I2C_ADDR);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Modo Analitico", 0, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Tipo Veiculo:", 2, 0);
    if (selected_vehicle_type == 0) {
        ssd1306_display_text(SSD1306_I2C_ADDR, "> Carro Passeio", 3, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "  SUV/Caminhonete", 4, 0);
    } else {
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Carro Passeio", 3, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "> SUV/Caminhonete", 4, 0);
    }
    ssd1306_display_text(SSD1306_I2C_ADDR, "(SELECT para prox)", 6, 0);
}

void display_analytical_load_type_selection() {
    ssd1306_clear_display(SSD1306_I2C_ADDR);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Modo Analitico", 0, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Tipo Carga:", 2, 0);
    if (selected_load_type == 0) {
        ssd1306_display_text(SSD1306_I2C_ADDR, "> Vazio", 3, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Carga Media", 4, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Carga Maxima", 5, 0);
    } else if (selected_load_type == 1) {
        ssd1306_display_text(SSD1306_I2C_ADDR, "> Carga Media", 4, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Carga Maxima", 5, 0);
    } else {
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Vazio", 3, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "  Carga Media", 4, 0);
        ssd1306_display_text(SSD1306_I2C_ADDR, "> Carga Maxima", 5, 0);
    }
    ssd1306_display_text(SSD1306_I2C_ADDR, "(SELECT para prox)", 6, 0);
}

void display_analytical_result() {
    char pressure_suggestion[32];
    // Lógica de sugestão de pressão baseada na pesquisa
    if (selected_vehicle_type == 0) { // Carro de Passeio
        if (selected_load_type == 0) { // Vazio
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 30-32 PSI");
        } else if (selected_load_type == 1) { // Carga Media (assumindo como vazio para simplificar)
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 30-32 PSI");
        } else { // Carga Maxima
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 34-36 PSI");
        }
    } else { // SUV/Caminhonete
        if (selected_load_type == 0) { // Vazio
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 35-38 PSI");
        } else if (selected_load_type == 1) { // Carga Media (assumindo como vazio para simplificar)
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 35-38 PSI");
        } else { // Carga Maxima
            snprintf(pressure_suggestion, sizeof(pressure_suggestion), "Sugestao: 40-45 PSI");
        }
    }

    ssd1306_clear_display(SSD1306_I2C_ADDR);
    ssd1306_display_text(SSD1306_I2C_ADDR, "Modo Analitico", 0, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, pressure_suggestion, 2, 0);
    ssd1306_display_text(SSD1306_I2C_ADDR, "(SELECT para reiniciar)", 4, 0);
}

// Task principal para leitura dos sensores e atualização do display
void main_task(void *pvParameters) {
    float temperature = 0.0, pressure_hpa = 0.0, pressure_psi = 0.0;

    while (1) {
        // Leitura dos sensores apenas no modo padrão ou antes de exibir o resultado analítico
        if (current_mode == MODE_STANDARD) {
            esp_err_t bmp_ret = bmp280_read_temperature_and_pressure(BMP280_I2C_ADDR_0, &temperature, &pressure_hpa);
            if (bmp_ret != ESP_OK) {
                ESP_LOGE(TAG, "Falha ao ler do BMP280");
            }

            esp_err_t smp_ret = smp3011_read_pressure(SMP3011_I2C_ADDR, &pressure_psi);
            if (smp_ret != ESP_OK) {
                ESP_LOGE(TAG, "Falha ao ler do SMP3011");
            }
        }

        // Atualiza o display com base no modo atual
        switch (current_mode) {
            case MODE_STANDARD:
                display_standard_mode(temperature, pressure_hpa, pressure_psi);
                break;
            case MODE_ANALYTICAL_VEHICLE_TYPE:
                display_analytical_vehicle_type_selection();
                break;
            case MODE_ANALYTICAL_LOAD_TYPE:
                display_analytical_load_type_selection();
                break;
            case MODE_ANALYTICAL_RESULT:
                display_analytical_result();
                break;
        }

        vTaskDelay(pdMS_TO_TICKS(200)); // Atualiza a cada 200ms para melhor responsividade dos botões
    }
}

extern "C" {
    void app_main();
}

void app_main() {
    ESP_LOGI(TAG, "Iniciando o Projeto de Sensor de Pressão para Pneus...");

    // Configuração dos pinos GPIO para os botões
    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_NEGEDGE; // Interrupção na borda de descida (botão pressionado)
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pull_up_en = GPIO_PULLUP_ENABLE;
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pin_bit_mask = (1ULL << BUTTON_UP_PIN) | (1ULL << BUTTON_DOWN_PIN) | (1ULL << BUTTON_SELECT_PIN);
    gpio_config(&io_conf);

    gpio_evt_queue = xQueueCreate(10, sizeof(uint32_t));
    gpio_install_isr_service(0);
    gpio_isr_handler_add(BUTTON_UP_PIN, gpio_isr_handler, (void*) BUTTON_UP_PIN);
    gpio_isr_handler_add(BUTTON_DOWN_PIN, gpio_isr_handler, (void*) BUTTON_DOWN_PIN);
    gpio_isr_handler_add(BUTTON_SELECT_PIN, gpio_isr_handler, (void*) BUTTON_SELECT_PIN);

    xTaskCreate(button_task, "button_task", 2048, NULL, 10, NULL);

    // Inicializa o driver I2C
    esp_err_t ret = i2c_master_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Falha ao inicializar o driver I2C");
        return;
    }

    // Inicializa os sensores
    ret = bmp280_init(BMP280_I2C_ADDR_0);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Falha ao inicializar o BMP280");
    }

    ret = smp3011_init(SMP3011_I2C_ADDR);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Falha ao inicializar o SMP3011");
    }

    // Inicializa o display OLED
    ret = ssd1306_init(SSD1306_I2C_ADDR);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Falha ao inicializar o SSD1306");
    }

    // Cria a task principal
    xTaskCreate(main_task, "main_task", 4096, NULL, 5, NULL);

    ESP_LOGI(TAG, "Inicialização completa. O sistema está em execução.");
}

            </code></pre>
           
            <section>
                <h2>Fluxo de Funcionamento</h2>
                <p>O sistema opera em dois modos principais, com transições controladas por botões físicos:</p>
                <h3>Modo Padrão</h3>
                <p>Neste modo, o dispositivo realiza leituras contínuas dos sensores BMP280 (temperatura e pressão barométrica) e SMP3011 (pressão do pneu em PSI). Os dados são exibidos em tempo real no display OLED, fornecendo ao usuário informações diretas sobre as condições do pneu e ambiente.</p>
                <h3>Modo Analítico</h3>
                <p>O modo analítico oferece uma funcionalidade mais avançada, sugerindo a pressão ideal para o pneu com base em parâmetros fornecidos pelo usuário. O fluxo de interação é o seguinte:</p>
                <ol>
                    <li><strong>Seleção do Tipo de Veículo:</strong> O usuário escolhe entre
                        Carro de Passeio e SUV/Caminhonete usando os botões UP (GPIO0) e DOWN (GPIO4).
                        *   **Seleção do Tipo de Carga:** Após selecionar o tipo de veículo, um clique no botão SELECT/MODE avança para a seleção do tipo de carga (Vazio, Carga Média, Carga Máxima), também navegável com os botões UP e DOWN.
                        *   **Sugestão de Calibragem:** Após selecionar o tipo de carga, um clique no botão SELECT/MODE exibe uma sugestão de faixa de pressão em PSI, baseada em uma lógica simplificada (ver `main.cpp` para detalhes).
                        *   **Reiniciar/Voltar:** Um clique no botão SELECT/MODE na tela de resultado reinicia o processo de seleção do modo analítico. Dois cliques rápidos no botão SELECT/MODE a qualquer momento retornam ao Modo Padrão.
                </ol>
            </section>
            <ul class="callout">
                <li>O código acima é um exemplo didático: a conversão  → pressão deve ser calibrada com leituras de referência.</li>
                <li>Para maior precisão, use leituras médias (filtering) e compensação térmica.</li>                
            </ul>
        </section>

        <section class="mt-1">
            <h2 style="color:#1e3d58;">6. Montagem e Testes (plano)</h2>
            <ol>
                <li>Montar protótipo em protoboard e verificar leituras brutas.</li>
                <li>Calibrar conversão do SMP3011 com medidor de referência (Vonder ou máquina certificada).</li>
                <li>Testes de estabilidade: variação de leituras por 10 min, checar ruído.</li>
                <li>Testes de ergonomia: operação com luvas, visibilidade do OLED em diferentes iluminações.</li>
                <li>Validação de campo: comparar 30 leituras reais em pneus frios/quentes com equipamento padrão.</li>
            </ol>
            <div class="note">Meta: garantir precisão dentro de ±5% da escala, conforme requisito do projeto.</div>
        </section>

        <section class="mt-1">
            <h2 style="color:#1e3d58;">7. Tabela Técnica Estendida (comparativa)</h2>
            <table class="specs">
                <tr><th>Produto / Parâmetro</th><th>Tipo</th><th>Precisão</th><th>Conect.</th><th>Preço (R$)</th></tr>
                <tr><td class="left">Vonder MDP151</td><td>Portátil</td><td>~±5%</td><td>—</td><td>≈ 80–120</td></tr>
                <tr><td class="left">Xiaomi 70mai TPMS</td><td>Embutido</td><td>~±3–5%</td><td>Bluetooth/App</td><td>≈ 300–400</td></tr>
                <tr><td class="left">Cofap TPMS</td><td>Embutido</td><td>~±2–4%</td><td>Display / sensores válvula</td><td>≈ 400–600</td></tr>
                <tr><td class="left"><strong>Projeto ESP32 (este)</strong></td><td>Portátil Inteligente</td><td>Objetivo ±5%</td><td>Offline, opcional Wi-Fi</td><td>&lt; 200</td></tr>
            </table>
        </section>

        <section class="mt-1">
            <h2 style="color:#1e3d58;">8. Referências e materiais úteis</h2>
            <ul >
                <li>Datasheet BMP280 — Bosch Sensortec</li>
                <li>Datasheet SMP3011 — [consultar fabricante específico do sensor]</li>
                <li>Adafruit SSD1306 library documentation</li>
                <li>Relatórios de segurança rodoviária — órgãos nacionais (DENATRAN/DETRAN)</li>
                <li>Manuais técnicos de fabricantes (Michelin, Bridgestone)</li>
            </ul>
            <p class="small">(Para a versão final do TCC/PI, as referências serão formatadas em ABNT e detalhadas no arquivo `contato.html` / referências).</p>
        </section>

        <section style="margin-top:1rem;display:flex;gap:1rem;flex-wrap:wrap;">
            <a href="prototipo.html" class="btn-primary" style="text-decoration:none;padding:12px 16px;border-radius:8px;">Ir para Protótipo & Código</a>
            <a href="index.html" class="btn-secondary" style="text-decoration:none;padding:12px 16px;border-radius:8px;">Voltar à Home</a>
        </section>

    </main>

    <footer>
        <div class="footer-container">
            <div class="footer-content">
                <div>
                <strong>Projeto:</strong> Aferidor Inteligente de Pneus — Trabalho de Limguagem de programação para microcontroladores (2025)
                </div>
                <div class="footer-note"> Faculdade de Tecnologia de Jundiaí.</div>
            </div>        
        </div>
    </footer>  
    
</body>
</html>